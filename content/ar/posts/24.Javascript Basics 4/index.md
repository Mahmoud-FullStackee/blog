---
title: "أنماط الدوال في JavaScript: فهم Scope، Shadowing، Hoisting، والتعبيرات الوظيفية"
date: 2024-12-14
draft: true
slug: "javascript-function-scopes-shadowing-hoisting-expressions"
description: "تعلم أساسيات JavaScript من خلال فهم Scope، Shadowing، Hoisting، والتعبيرات الوظيفية لتطوير مهاراتك البرمجية."
summary: "تعلم أساسيات JavaScript من خلال فهم Scope، Shadowing، Hoisting، والتعبيرات الوظيفية لتطوير مهاراتك البرمجية."
cascade:
  showReadingTime: true
categories: ['Web Development']
tags: ['Front-End','CSS']
---

تعتبر JavaScript واحدة من اللغات الأكثر استخدامًا في تطوير الويب، ولذا فإن فهم أسسها يعد أمرًا ضروريًا لأي مطور. في هذا المقال، سنتناول موضوعًا بالغ الأهمية في البرمجة باستخدام JavaScript، وهو كيفية التعامل مع الأنماط المختلفة للدوال. سنستعرض معًا الـ Scope، الـ Shadowing، الـ Hoisting، والتعبيرات الوظيفية، بالإضافة إلى الأمثلة العملية التي توضح كيف تؤثر هذه المفاهيم على سير عملك في البرمجة. إن فهم هذه المفاهيم سيزيد من قدرتك على كتابة أكواد أكثر كفاءة ومرونة. إذا كنت ترغب في تطوير مهاراتك في JavaScript، لا تفوت فرصة التعمق في هذا المقال!


## مقدمة عن الدوال في JavaScript

تُعد الدوال (Functions) في JavaScript واحدة من الأدوات الأساسية التي تمكننا من التحكم في تدفق البرامج باستخدام العبارات الشرطية والحلقات التكرارية. مع القليل من الأدوات البسيطة، يمكنك بالفعل إنشاء برامج مذهلة. لكن ماذا يحدث إذا أصبح الكود أطول؟ بالطبع ستواجه مواقف يتكرر فيها نفس الكود عدة مرات. لحل هذه المشكلة، يمكننا تجميع هذه العمليات المتكررة في وحدات قابلة لإعادة الاستخدام تُسمى "الدوال".

لفهم مدى أهمية الدوال، دعونا نفكر في مثال بسيط من حياتنا اليومية: الميكروويف. عندما ترغب في تسخين البيتزا (لأن تناول البيتزا الباردة ليس ممتعاً)، تحتاج إلى ضبط الميكروويف وفقاً لعدد شرائح البيتزا. لنقل إن كل شريحة تحتاج إلى دقيقة ونصف للتسخين. بعدها، تقوم بضبط قوة الميكروويف على 50% للتسخين بدلاً من الطهي، ثم تضغط على زر البدء وتنتظر حتى تصبح البيتزا جاهزة.

هذه الطريقة تعمل بالتأكيد، لكنها قد تكون مرهقة، خاصة إذا كنت تضطر لتكرار الإعدادات كل مرة. لكن لحسن الحظ، يحتوي الميكروويف على زر خاص يُسمى "Reheat Pizza" الذي يقوم بضبط الوقت والقوة تلقائياً. كل ما عليك فعله هو تحديد عدد الشرائح، والباقي يتم تلقائياً. 

زر "Reheat Pizza" يشبه تماماً الدوال في البرمجة. فهي عبارة عن مجموعة من الأسطر البرمجية مجمعة معاً يمكننا استخدامها وإعادة استخدامها وقت الحاجة. معظم الدوال تأخذ بيانات، تُجري عمليات عليها، وتعيد النتائج. على سبيل المثال، في حالة زر البيتزا، البيانات المُدخلة هي عدد شرائح البيتزا، والعملية هي ضبط الوقت والقوة، والنتيجة هي بيتزا ساخنة جاهزة للأكل.

الدوال تُسهل علينا الأمور، تماماً كما يُسهل زر إعادة تسخين البيتزا إعداد الوجبة، دون الحاجة إلى ضبط كل شيء من الصفر في كل مرة.


## مثال على الدوال في JavaScript

تنوع المدخلات هو أداة قوية عندما تقوم بإنشاء برامج. لتوضيح الفكرة، دعنا نلقي نظرة على مثال بسيط لدالة تقوم بعكس النصوص. على سبيل المثال، إذا قمت بتمرير النص "Julia" كمعطى لهذه الدالة، فإنها ستعيد النص معكوسًا ليصبح "ailuJ".

هناك عدة خطوات متداخلة لجعل هذه العملية تعمل. 

1. **تعريف المعطى**: الدالة تحتوي على معامل (Parameter) يُسمى `reverseMe`. يتم استخدام هذا المعامل لتمرير النص المطلوب عكسه، في هذه الحالة النص "Julia".
   
2. **المتغير الداخلي**: داخل الدالة، يتم تعريف متغير يُسمى `reverse`، والذي سيحمل النص النهائي المعكوس.

3. **عملية التكرار**: الدالة تستخدم حلقة للتنقل عبر النص من النهاية إلى البداية، وتقوم بإضافة كل حرف إلى المتغير `reverse` بالترتيب الجديد.

4. **إرجاع النتيجة**: بمجرد انتهاء الحلقة، تعيد الدالة النص المعكوس باستخدام الكلمة المفتاحية `return`. يمكنك بعد ذلك طباعة النتيجة باستخدام `console.log`.

## الفائدة من استخدام الدوال
إذا لم تكن هذه الخطوات ملفوفة داخل دالة، فسيتوجب عليك كتابة نفس الكود في كل مرة تحتاج فيها إلى عكس نص معين. لكن باستخدام الدالة، يتم تغليف كل هذه الخطوات معًا في مكان واحد. هذا يجعل العملية أكثر بساطة وكفاءة، حيث يمكنك إعادة استخدام الدالة مع أي نص آخر بمجرد استدعائها وتمرير النص المطلوب.

## كيف تعمل الدوال؟
الدوال في JavaScript هي وسيلة لتجميع منطق معين داخل وحدة قابلة لإعادة الاستخدام. يمكنك تعريفها باستخدام عدة طرق، واستدعاؤها بتمرير مدخلات مختلفة للحصول على نتائج مخصصة لكل حالة. 

الدوال تجعل كودك منظمًا، قابلًا للصيانة، وأقل تكرارًا. لذلك، سواء كنت مبتدئًا أو مبرمجًا محترفًا، فإن فهم كيفية تعريف الدوال واستخدامها هو خطوة أساسية في كتابة كود نظيف وفعال.


## القيم المرجعة (Return Values) في JavaScript

عند كتابة الشيفرة، غالبًا ما تحتاج إلى إنتاج مخرجات تظهر على الشاشة. في البداية، قد تستخدم `console.log` لعرض رسائل في وحدة التحكم (Console). هذا شيء ربما قمت به في دروس سابقة. لكن ربما لاحظت عند استخدام `console.log` أن الكلمة **`undefined`** ظهرت بعد الرسالة التي طبعتها. فما هو سبب ذلك؟

### مفهوم `undefined`
عندما تستدعي دالة في JavaScript، فإنها دائمًا تُرجع قيمة. إذا لم تُحدّد قيمة صراحة باستخدام الكلمة المفتاحية `return`، فإن JavaScript تُرجع القيمة الافتراضية **`undefined`**.

على سبيل المثال، عند استخدام `console.log` وتمرير رسالة لها كمعامل، فإنها تطبع الرسالة في وحدة التحكم لكنها في نفس الوقت تُرجع **`undefined`**. بمعنى آخر، هناك فرق بين طباعة المخرجات باستخدام `console.log` وبين إرجاع القيم باستخدام `return`.

### الفرق بين `console.log` و `return`
1. **`console.log`**: تُستخدم لطباعة قيمة أو رسالة على الشاشة بهدف الاختبار أو التحقق من الشيفرة.
2. **`return`**: تُستخدم لإرجاع قيمة من الدالة إلى الجزء الذي استدعاها، كما أنها توقف تنفيذ الدالة عند النقطة التي تُستدعى فيها.

### مثال لتوضيح الفرق
لنفترض أننا كتبنا دالة تُحدد ما إذا كان الرقم أوليًا (Prime Number). الرقم الأولي هو رقم لا يقبل القسمة إلا على نفسه وعلى الرقم 1. سنستخدم الدالة لتوضيح الفرق بين `console.log` و `return`.

```javascript
function isPrime(number) {
    for (let i = 2; i < number; i++) {
        if (number % i === 0) {
            console.log(`${number} is divisible by ${i}`);
            return false;
        }
    }
    return true;
}
```

#### تحليل الدالة:
1. إذا كان الرقم غير أولي (يقبل القسمة على رقم آخر غير نفسه و1):
   - تطبع رسالة باستخدام `console.log` لتوضيح الرقم الذي يقسمه.
   - تُرجع القيمة `false` باستخدام `return`.
   - تتوقف الدالة عن التنفيذ.

2. إذا كان الرقم أوليًا:
   - تُرجع القيمة `true`.

#### تجربة الكود:
- إذا استدعيت الدالة بـ `isPrime(11)`:
  - الرقم 11 أولي.
  - النتيجة التي ستُرجعها الدالة هي `true`.

- إذا استدعيت الدالة بـ `isPrime(49)`:
  - الرقم 49 ليس أوليًا لأنه يقبل القسمة على 7.
  - الدالة تطبع: "49 is divisible by 7".
  - تُرجع `false`.

### ماذا يحدث عند حذف `return`؟
إذا أزلنا جميع عبارات `return` من الدالة واستدعيناها:
- ستظل الدالة تطبع الرسائل عند القسمة، لكنها لن تُرجع أي قيمة. 
- القيمة المرجعة الافتراضية ستكون **`undefined`**.

### الخلاصة
1. **`return`** تُستخدم لإرجاع قيم وإيقاف تنفيذ الدالة.
2. **`console.log`** تُستخدم لطباعة الرسائل ولا تُرجع أي شيء.
3. إذا لم تُحدّد قيمة مرجعة في دالة، فستُرجع **`undefined`** افتراضيًا.

فهم الفرق بين `console.log` و `return` يساعدك في كتابة شيفرة أكثر كفاءة وتنظيمًا.


## مفهوم النطاق (Scope) في البرمجة

عندما نناقش النطاق (Scope) في البرمجة، فإننا نتحدث عن الجزء من البرنامج الذي يمكن فيه الوصول إلى هوية معينة (مثل اسم متغير أو اسم دالة). 

### تشبيه النطاق بالمكتبة
لفهم الفكرة بشكل أفضل، دعنا نأخذ مثالًا للمكتبة:
- إذا كنت داخل مكتبة، يمكنك طلب كتاب والحصول على معلومات حوله لأنك في المكان الصحيح (النطاق الصحيح).
- أما إذا كنت خارج المكتبة، فلن تتمكن من الحصول على الكتاب أو معلومات عنه لأنه خارج نطاقك.

### كيف يعمل النطاق في البرمجة؟
النطاق يحدد **أين يمكن استخدام المتغير أو الدالة** في الكود. هناك نوعان رئيسيان من النطاقات:

#### 1. **النطاق المحلي (Local Scope):**
   - عندما تُعرّف متغيرًا داخل دالة، فإن هذا المتغير يكون مرئيًا **فقط** داخل تلك الدالة.
   - بمجرد انتهاء تنفيذ الدالة، يتم "تدمير" المتغير ولم يعد موجودًا.

   **مثال:**
   ```javascript
   function sayHello() {
       let message = "Hello, World!"; // متغير محلي
       console.log(message); // يمكن الوصول إلى message هنا
   }
   sayHello();
   // console.log(message); // خطأ! message ليس في النطاق هنا
   ```

#### 2. **النطاق العام (Global Scope):**
   - إذا تم تعريف متغير خارج جميع الدوال، فإنه يكون مرئيًا في أي مكان داخل البرنامج.
   - لكن استخدام المتغيرات العامة بإفراط قد يؤدي إلى تعقيد الكود وزيادة الأخطاء.

   **مثال:**
   ```javascript
   let globalMessage = "I am global!"; // متغير عام

   function showMessage() {
       console.log(globalMessage); // يمكن الوصول إلى globalMessage هنا
   }

   showMessage();
   console.log(globalMessage); // يمكن الوصول إلى globalMessage هنا أيضًا
   ```

### **قواعد النطاق في JavaScript:**
1. **Block Scope (نطاق الكتلة):**
   - الكلمات المفتاحية `let` و `const` لديها نطاق الكتلة.
   - يعني ذلك أن المتغيرات المعرّفة باستخدامهما مرئية فقط داخل الكتلة `{}` التي تم تعريفها فيها.

   **مثال:**
   ```javascript
   {
       let blockScoped = "I'm inside a block!";
       console.log(blockScoped); // يعمل هنا
   }
   // console.log(blockScoped); // خطأ! blockScoped ليس في النطاق
   ```

2. **Function Scope (نطاق الدالة):**
   - المتغيرات المعرّفة باستخدام `var` تكون مرئية داخل الدالة التي تم تعريفها فيها.

   **مثال:**
   ```javascript
   function testVar() {
       if (true) {
           var functionScoped = "I'm function scoped!";
       }
       console.log(functionScoped); // يعمل هنا
   }
   testVar();
   ```

3. **Global Scope (النطاق العام):**
   - أي متغير يتم تعريفه خارج الدوال يكون في النطاق العام ويمكن الوصول إليه من أي مكان في الكود.

### **أخطاء شائعة تتعلق بالنطاق:**
1. **إعادة تعريف المتغيرات في نطاق غير مقصود:**
   ```javascript
   let name = "Alice";

   function greet() {
       let name = "Bob"; // تم تعريف متغير جديد محليًا
       console.log(name); // "Bob"
   }

   greet();
   console.log(name); // "Alice"
   ```

2. **الوصول إلى متغير خارج نطاقه:**
   ```javascript
   function calculate() {
       let result = 42;
   }

   // console.log(result); // خطأ! result ليس في النطاق
   ```

### الخلاصة:
- **النطاق** يحدد أين يمكن الوصول إلى المتغيرات والدوال.
- فهم النطاق يساعدك على كتابة كود منظم وتجنب الأخطاء.
- استخدم `let` و `const` بدلاً من `var` لتجنب الالتباس المتعلق بالنطاق.


## مثال على **النطاق** (Scope) في JavaScript

في JavaScript، هناك نوعان رئيسيان من النطاق: **النطاق العام (Global Scope)** و**نطاق الوظيفة (Function Scope)**. لنلقِ نظرة على تعريف كل منهما:

### 1. النطاق العام (Global Scope)  
عند تعريف متغير **خارج جميع الوظائف (functions)**، فإنه يُعتبر جزءًا من النطاق العام. هذا يعني أن هذا المتغير يمكن الوصول إليه من أي مكان في البرنامج.

### 2. نطاق الوظيفة (Function Scope)  
عند تعريف متغير **داخل وظيفة (function)**، فإنه يُعتبر جزءًا من نطاق الوظيفة. هذا يعني أن المتغير يكون مرئيًا ومتاحًا فقط داخل الوظيفة التي تم تعريفه فيها.

---

### مثال برمجي

```javascript
// نطاق عام (Global Scope)
let james = "جيمس"; // متغير عام

function library() {
    // نطاق الوظيفة (Function Scope) داخل الوظيفة `library`
    let librarian = "السيد أحمد"; // متغير محلي خاص بهذه الوظيفة

    console.log(james); // متاح: `james` متغير في النطاق العام
    console.log(librarian); // متاح: `librarian` معرف داخل هذه الوظيفة

    function classicLiterature() {
        // نطاق الوظيفة (Function Scope) داخل الوظيفة `classicLiterature`
        let book = "رواية كلاسيكية"; // متغير محلي خاص بهذه الوظيفة

        console.log(james); // متاح: `james` متغير في النطاق العام
        console.log(librarian); // متاح: `librarian` متغير في الوظيفة الخارجية
        console.log(book); // متاح: `book` معرف داخل الوظيفة الحالية
    }

    // classicLiterature(); // استدعاء الوظيفة الفرعية
    // console.log(book); // خطأ: `book` غير متاح خارج `classicLiterature`
}

// library(); // استدعاء الوظيفة الرئيسية
// console.log(librarian); // خطأ: `librarian` غير متاح خارج الوظيفة `library`
```

---

### الشرح

1. **المتغير `james`:**  
   - معرف في النطاق العام.  
   - يمكن الوصول إليه من أي وظيفة مثل `library` أو `classicLiterature`.

2. **المتغير `librarian`:**  
   - معرف داخل الوظيفة `library`.  
   - مرئي فقط داخل الوظيفة `library` وجميع الوظائف الفرعية داخلها مثل `classicLiterature`.

3. **المتغير `book`:**  
   - معرف داخل الوظيفة `classicLiterature`.  
   - مرئي فقط داخل `classicLiterature` وغير متاح خارجها.

---

### كيف يعمل النطاق؟  
عندما يحاول محرك JavaScript البحث عن معرف (identifier)، فإنه يتبع التسلسل التالي:

1. يبحث داخل الوظيفة الحالية.  
2. إذا لم يتم العثور عليه، ينتقل إلى النطاق الخارجي (الوظيفة الخارجية).  
3. يستمر في الانتقال إلى النطاقات الأعلى حتى يصل إلى النطاق العام.  
4. إذا لم يتم العثور على المعرف في أي مستوى، يُصدر **خطأ مرجعي (ReferenceError)**.

---

### ملاحظات:
- المتغيرات المعرفة في النطاق العام تُعتبر قابلة للوصول عالميًا، ولكن استخدامها بكثرة قد يؤدي إلى أخطاء أو تداخل في الكود.  
- لتجنب الأخطاء، يُفضل تعريف المتغيرات في نطاقات محلية عند الحاجة فقط.  


## **Shadowing في JavaScript**

عند التعامل مع المتغيرات بين النطاق العام (Global Scope) ونطاق الوظيفة (Function Scope)، يمكن أن تواجه مشكلة تُعرف باسم **"إعادة تعريف النطاق"** أو **"Shadowing"**.  

### **ما هو Shadowing؟**  
عندما يتم تعريف متغير بنفس الاسم في نطاقين مختلفين، فإن المتغير المحلي (داخل الوظيفة) "يُخفي" المتغير العام (في النطاق العام) عند استخدامه داخل النطاق المحلي. قد يؤدي ذلك أحيانًا إلى نتائج غير متوقعة إذا تم تعديل المتغير العام عن غير قصد.

---

### **مثال على Shadowing**

```javascript
// تعريف متغير في النطاق العام
let bookTitle = "La Petite Prince"; // العنوان باللغة الفرنسية

function displayBookEnglish() {
    // تعريف متغير بنفس الاسم داخل نطاق الوظيفة
    bookTitle = "The Little Prince"; // العنوان باللغة الإنجليزية
    console.log("Inside function:", bookTitle); // يطبع "The Little Prince"
}

console.log("Before function call:", bookTitle); // يطبع "La Petite Prince"
displayBookEnglish(); // استدعاء الوظيفة
console.log("After function call:", bookTitle); // يطبع "The Little Prince"
```

#### **ماذا حدث هنا؟**
- المتغير `bookTitle` تم تعريفه في النطاق العام بقيمة `"La Petite Prince"`.  
- داخل الوظيفة `displayBookEnglish`، قمنا بإعادة تعريف نفس المتغير `bookTitle` (ولكن في الواقع، قمنا بتعديل المتغير العام).  
- عند طباعة `bookTitle` بعد الخروج من الوظيفة، نجد أن القيمة الأصلية قد تغيرت إلى `"The Little Prince"`.

---

### **كيف نتجنب Shadowing؟**

لتجنب إعادة تعريف المتغير العام عن طريق الخطأ، يمكنك استخدام **متغير محلي جديد** داخل الوظيفة باستخدام `let` أو `const`. بهذه الطريقة، يكون للمتغير الجديد نطاقه الخاص داخل الوظيفة.

#### **مثال مع تجنب Shadowing**

```javascript
// تعريف متغير في النطاق العام
let bookTitle = "La Petite Prince"; // العنوان باللغة الفرنسية

function displayBookEnglish() {
    // تعريف متغير جديد داخل نطاق الوظيفة
    let localBookTitle = "The Little Prince"; // العنوان باللغة الإنجليزية
    console.log("Inside function:", localBookTitle); // يطبع "The Little Prince"
}

console.log("Before function call:", bookTitle); // يطبع "La Petite Prince"
displayBookEnglish(); // استدعاء الوظيفة
console.log("After function call:", bookTitle); // يطبع "La Petite Prince"
```

#### **ماذا حدث الآن؟**
- تم تعريف متغير جديد داخل الوظيفة (`localBookTitle`) بدلاً من تعديل المتغير العام.  
- عند طباعة `bookTitle` بعد الخروج من الوظيفة، لم تتغير قيمته الأصلية.

---

### **نصائح لتجنب الأخطاء بسبب Shadowing:**
1. **استخدام `let` أو `const` دائماً لتعريف المتغيرات بدلاً من `var`.**  
   - `var` يمكن أن يسبب مشاكل بسبب نطاقه المختلف (Global/Function).

2. **اختر أسماء متغيرات مميزة وواضحة.**  
   - يساعد ذلك في تجنب التداخل بين النطاقات المختلفة.

3. **تقليل استخدام المتغيرات في النطاق العام.**  
   - يُفضل إبقاء المتغيرات محصورة في النطاقات التي تحتاجها فقط.

4. **اختبار الكود بشكل دوري.**  
   - تحقق من القيم المتوقعة للمتغيرات لتفادي التغييرات غير المقصودة.

---

### **الملخص**
- **Shadowing** يحدث عندما يتم تعريف متغير بنفس الاسم في نطاقات مختلفة.  
- لتجنب هذه المشكلة، استخدم متغيرات محلية جديدة داخل النطاقات المختلفة، وتجنب تعديل المتغيرات العامة داخل الوظائف دون قصد.


## **Hoisting في JavaScript**

**Hoisting** هي ميزة في JavaScript يتم بموجبها "رفع" تعريفات الدوال والمتغيرات إلى أعلى النطاق (Scope) أثناء معالجة الكود.  
هذا يعني أنه يمكن استدعاء دالة أو استخدام متغير قبل تعريفه فعليًا في الكود. ومع ذلك، فإن القيم الخاصة بالمتغيرات لا يتم رفعها، وإنما يتم رفع **التصريح** فقط.

---

### **Hoisting مع الدوال**

في JavaScript، يتم رفع تعريفات **الدوال المُصرح بها (Function Declarations)** بالكامل إلى أعلى النطاق، مما يسمح باستدعاء الدالة قبل تعريفها في الكود.

#### **مثال على رفع الدوال**
```javascript
console.log(findAverage(4, 8)); // يعمل بشكل صحيح

function findAverage(a, b) {
    return (a + b) / 2;
}
```

#### **كيف يعمل؟**
- عندما يتم تفسير الكود، يتم رفع تعريف الدالة `findAverage` إلى أعلى النطاق.  
- هذا يعني أنه يمكن استدعاء الدالة حتى لو تم تعريفها لاحقًا في الكود.

---

### **Hoisting مع المتغيرات**

عند التعامل مع المتغيرات، يحدث رفع للتصريح فقط (Declaration) وليس للقيمة (Value).  
- إذا استخدمت متغيرًا قبل تعريفه، فستحصل على `undefined` إذا كان التصريح باستخدام `var`.
- عند استخدام `let` أو `const`، سيؤدي استخدام المتغير قبل تعريفه إلى حدوث خطأ.

#### **مثال مع `var`**
```javascript
console.log(greeting); // undefined
var greeting = "Hello";
console.log(greeting); // Hello
```

#### **كيف يعمل؟**
- التصريح عن المتغير `greeting` يتم رفعه إلى الأعلى، لكن القيمة `Hello` تبقى في مكانها.  
- أثناء التنفيذ، يصبح المتغير موجودًا ولكن بدون قيمة، لذلك تكون النتيجة `undefined`.

#### **مثال مع `let` أو `const`**
```javascript
console.log(greeting); // ReferenceError: Cannot access 'greeting' before initialization
let greeting = "Hello";
console.log(greeting);
```

- عند استخدام `let` أو `const`، يتم رفع التصريح، لكن المتغير يظل في **"المنطقة الزمنية المؤقتة"** (Temporal Dead Zone) حتى يصل التنفيذ إلى مكان تعريفه.

---

### **حل مشاكل Hoisting**

لتجنب الأخطاء الناتجة عن الرفع، يُنصح بـ:

1. **تعريف الدوال والمتغيرات في الأعلى:**
   - ضع الدوال في بداية الكود.
   - ضع المتغيرات في بداية كل وظيفة.

   #### **مثال منظم:**
   ```javascript
   // تعريف المتغيرات
   let greeting;

   // تعريف الدوال
   function sayHello() {
       console.log(greeting);
   }

   // استخدام المتغيرات
   greeting = "Hello";
   sayHello(); // Hello
   ```

2. **استخدام `let` و `const` بدلاً من `var`:**
   - يقلل ذلك من الأخطاء ويمنع الوصول إلى المتغير قبل تعريفه.

3. **تفادي الاعتماد على الرفع غير المرئي:**
   - نظم الكود بحيث يكون تعريف المتغيرات والدوال مرئيًا قبل الاستخدام.

---

### **الملخص**
- **الدوال المُصرح بها (Function Declarations)** يتم رفعها بالكامل، ويمكن استدعاؤها قبل تعريفها.
- **المتغيرات مع `var`** يتم رفع التصريح فقط، وتكون قيمتها `undefined` حتى تصل إلى السطر الذي يحتوي على التعيين.
- **المتغيرات مع `let` و `const`** يتم رفع التصريح، لكنها تبقى في "المنطقة الزمنية المؤقتة" حتى تصل إلى التعريف.  
- **أفضل ممارسة:** قم بتعريف الدوال والمتغيرات في الأعلى لجعل الكود واضحًا ومتسقًا مع طريقة التنفيذ.


## **تعريف Function Expressions في JavaScript**

في JavaScript، يمكنك تخزين الدوال داخل المتغيرات. عندما تُخزَّن دالة في متغير، يُطلق عليها اسم **Function Expression**.

### **الفرق بين Function Declaration و Function Expression:**

1. **Function Declaration:**
   - يتم تعريف الدالة باستخدام الكلمة المفتاحية `function` مع اسم الدالة.
   - يتم رفع (hoist) تعريف الدالة بالكامل إلى أعلى النطاق.
   - يمكن استدعاء الدالة قبل تعريفها في الكود.

   **مثال:**

   ```javascript
   console.log(greet()); // "Hello, World!"

   function greet() {
       return "Hello, World!";
   }
   ```

2. **Function Expression:**
   - يتم تخزين الدالة داخل متغير.
   - يمكن أن تكون الدالة **مجهولة الاسم** (Anonymous Function).
   - لا يتم رفع تعريف الدالة (فقط المتغير يتم رفعه بدون قيمة).
   - يجب تعريف الدالة قبل استدعائها.

   **مثال:**

   ```javascript
   const greet = function () {
       return "Hello, World!";
   };

   console.log(greet()); // "Hello, World!"
   ```

---

### **دالة مجهولة الاسم (Anonymous Function):**

عندما تُخزن الدالة داخل متغير، عادةً ما تكون بدون اسم لأن الاسم يصبح غير ضروري، حيث يمكن استخدام اسم المتغير لاستدعاء الدالة.

#### **مثال على دالة مجهولة الاسم:**

```javascript
const catSays = function () {
    return "Meow!";
};

console.log(catSays()); // "Meow!"
```

---

### **Function Expressions و Hoisting:**

- **Function Declarations** تُرفع بالكامل إلى أعلى النطاق، لذلك يمكن استدعاؤها قبل تعريفها.
- أما **Function Expressions**، فيتم رفع تعريف المتغير فقط، بينما تبقى القيمة (الدالة) في مكانها. وبالتالي، إذا حاولت استدعاء دالة تم تعريفها كـ Function Expression قبل تعريفها، ستواجه خطأ.

#### **مثال:**

```javascript
console.log(catSays()); // Error: catSays is not a function

var catSays = function () {
    return "Meow!";
};
```

#### **لماذا حدث الخطأ؟**
- تم رفع تعريف المتغير `catSays` فقط.
- عند استدعاء `catSays()`، لم يكن المتغير يحتوي على دالة بعد، لذا يظهر الخطأ.

---

### **متى تستخدم Function Expressions؟**

- عندما تحتاج إلى دالة مجهولة تُستخدم لمرة واحدة أو لا تتطلب اسمًا.
- عند الحاجة إلى ربط الدالة بسياق معين أو متغير معين.
- في حالات مثل **Callback Functions** أو عند العمل مع الدوال داخل الكائنات.


## **الأنماط مع التعبيرات الوظيفية (Function Expressions)**

في JavaScript، يمكنك تخزين دوال غير مسماة داخل متغيرات (التعبيرات الوظيفية غير المسماة)، كما يمكنك أيضًا إنشاء **التعبيرات الوظيفية المسماة**، حيث تحتوي الدالة على اسم. سنلقي نظرة على كيفية عمل هذا.

### **التعبيرات الوظيفية غير المسماة:**

كما رأينا سابقًا، يمكن تخزين دالة غير مسماة في متغير واستخدام هذا المتغير لاستدعاء الدالة. 

### **مثال على دالة غير مسماة:**

```javascript
const catSays = function() {
    return "Meow!";
};

// استدعاء الدالة
console.log(catSays());  // "Meow!"
```

### **التعبيرات الوظيفية المسماة:**

يمكنك أيضًا تخزين دالة مسماة داخل متغير، ولكن، عند استدعاء الدالة، يجب عليك استخدام اسم المتغير، وليس اسم الدالة. إذا حاولت استدعاء الدالة باستخدام اسمها مباشرة، ستحصل على **خطأ مرجعي (Reference Error)**.

### **مثال على دالة مسماة داخل التعبير الوظيفي:**

```javascript
const movie = function movie() {
    return "Inception";
};

// استدعاء الدالة باستخدام المتغير
console.log(movie());  // "Inception"

// محاولة استدعاء الدالة باستخدام اسمها مباشرة ستؤدي إلى خطأ
console.log(movie());  // سيعمل لأننا استخدمنا المتغير، وليس اسم الدالة مباشرة
```

في هذا المثال، نرى أن الدالة المسماة `movie` تم تخزينها في المتغير `movie`، وبالتالي يمكن استدعاؤها عبر المتغير فقط. إذا حاولت استدعاء الدالة باستخدام اسمها مباشرة (مثل `movie()` بدون استخدام المتغير)، فسيظهر لك **خطأ مرجعي (Reference Error)**.

### **لماذا تستخدم التعبيرات الوظيفية المسماة؟**

- **التعبيرات الوظيفية المسماة** مفيدة إذا كنت تريد أن تعطي اسمًا وظيفيًا واضحًا للدالة ولكن لا تريد أن تكون دالة التصريح متاحة في النطاق العام.
- **التعبيرات الوظيفية غير المسماة** تكون أكثر مرونة عندما تحتاج إلى دالة تستخدم في مكان واحد فقط ولا تحتاج إلى اسم واضح لها.

### **مثال على الفرق بين الدالة المجهولة والمسماة:**

```javascript
// دالة غير مسماة
const greet = function() {
    console.log("Hello!");
};

// دالة مسماة
const greetNamed = function greet() {
    console.log("Hello!");
};

greet();       // "Hello!"
greetNamed();  // "Hello!"

// الخطأ عند محاولة استدعاء الدالة المسماة بدون المتغير:
greet();       // "Hello!"
greetNamed();  // ReferenceError: greetNamed is not defined
```

**الملخص:**
- التعبيرات الوظيفية غير المسماة تُخزن في متغير ويمكن استدعاؤها عبر المتغير.
- التعبيرات الوظيفية المسماة تحتوي على اسم وتُخزن في متغير، ولكن لا يمكن استدعاؤها باستخدام اسمها، بل فقط عبر المتغير الذي خُزنت فيه.

## خاتمة
في ختام مقالنا، نكون قد تطرقنا إلى مفاهيم حيوية في JavaScript مثل الـ Scope، Shadowing، Hoisting، والتعبيرات الوظيفية. من خلال الفهم الصحيح لهذه الأنماط، يمكنك تحسين طريقة كتابة الأكواد الخاصة بك وتجنب الكثير من الأخطاء الشائعة التي قد تؤثر على أدائها. التلاعب الفعّال مع هذه الأنماط سيساعدك على كتابة أكواد نظيفة وقابلة للصيانة. إذا كنت مبتدئًا أو حتى محترفًا، استمر في استكشاف المزيد من مفاهيم JavaScript التي ستفتح أمامك آفاقًا واسعة من الإمكانيات في تطوير التطبيقات.